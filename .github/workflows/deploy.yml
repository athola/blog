name: Deploy to Production

on:
  workflow_run:
    workflows: ["Rust", "Database Migrations"]
    types: [completed]
    branches: [master]

env:
  CARGO_TERM_COLOR: always

jobs:
  # Check if DigitalOcean deployment is properly configured
  deployment-check:
    runs-on: ubuntu-latest
    timeout-minutes: 5  # Configuration checks should be fast
    if: github.event.workflow_run.conclusion == 'success'
    outputs:
      deploy-enabled: ${{ steps.check-config.outputs.enabled }}
      domain-accessible: ${{ steps.check-domain.outputs.accessible }}
    steps:
    - name: Check DigitalOcean configuration
      id: check-config
      run: |
        set -euo pipefail  # Exit on error, undefined vars, and pipe failures
        
        echo "Checking DigitalOcean deployment prerequisites..."
        
        # Security note: Never echo secrets directly to avoid log exposure
        # Check if required secrets are set and validate basic format
        if [ -z "${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}" ]; then
          echo "‚ùå DIGITALOCEAN_ACCESS_TOKEN secret not configured"
          echo "enabled=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # Validate DigitalOcean token format (should be 64 hex characters) - avoid logging secret
        DO_TOKEN_LENGTH=$(echo -n "${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}" | wc -c)
        if [ "$DO_TOKEN_LENGTH" -ne 64 ]; then
          echo "‚ùå DIGITALOCEAN_ACCESS_TOKEN has invalid length (expected: 64 characters)"
          echo "enabled=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # Check if token contains only valid hex characters (without logging the token)
        if ! echo "${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}" | grep -q '^[a-f0-9]*$'; then
          echo "‚ùå DIGITALOCEAN_ACCESS_TOKEN contains invalid characters (expected: hex only)"
          echo "enabled=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        if [ -z "${{ secrets.SURREAL_ADDRESS }}" ]; then
          echo "‚ùå SURREAL_ADDRESS secret not configured" 
          echo "enabled=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # Validate SurrealDB address format (should be URL-like) - avoid logging sensitive URL
        if ! echo "${{ secrets.SURREAL_ADDRESS }}" | grep -q '^https\?://[a-zA-Z0-9.-]\+\(:[0-9]\+\)\?.*$'; then
          echo "‚ùå SURREAL_ADDRESS has invalid URL format (expected: http(s)://host[:port])"
          echo "enabled=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        if [ -z "${{ secrets.SURREAL_PASSWORD }}" ]; then
          echo "‚ùå SURREAL_PASSWORD secret not configured"
          echo "enabled=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # Validate password strength (minimum 8 characters) - avoid logging password
        PASSWORD_LENGTH=$(echo -n "${{ secrets.SURREAL_PASSWORD }}" | wc -c)
        if [ "$PASSWORD_LENGTH" -lt 8 ]; then
          echo "‚ùå SURREAL_PASSWORD is too weak (minimum 8 characters required, current: $PASSWORD_LENGTH)"
          echo "enabled=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # Validate additional SurrealDB configuration secrets
        if [ -z "${{ secrets.SURREAL_NS }}" ]; then
          echo "‚ùå SURREAL_NS secret not configured"
          echo "enabled=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        if [ -z "${{ secrets.SURREAL_DB }}" ]; then
          echo "‚ùå SURREAL_DB secret not configured"
          echo "enabled=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        if [ -z "${{ secrets.SURREAL_USERNAME }}" ]; then
          echo "‚ùå SURREAL_USERNAME secret not configured"
          echo "enabled=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # Basic validation for namespace and database names (should be alphanumeric)
        if ! echo "${{ secrets.SURREAL_NS }}" | grep -q '^[a-zA-Z][a-zA-Z0-9_-]*$'; then
          echo "‚ùå SURREAL_NS has invalid format (expected: alphanumeric starting with letter)"
          echo "enabled=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        if ! echo "${{ secrets.SURREAL_DB }}" | grep -q '^[a-zA-Z][a-zA-Z0-9_-]*$'; then
          echo "‚ùå SURREAL_DB has invalid format (expected: alphanumeric starting with letter)"
          echo "enabled=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        echo "‚úÖ All required secrets are configured and validated"
        echo "enabled=true" >> $GITHUB_OUTPUT
    
    - name: Test domain accessibility
      id: check-domain
      timeout-minutes: 2  # Network tests should be quick
      run: |
        set -euo pipefail  # Exit on error, undefined vars, and pipe failures
        
        echo "Testing domain accessibility for alexthola.com..."
        
        # Check if domain is accessible via HTTPS (more reliable than ping for web services)
        # Try both the main domain and any health endpoint that might exist
        DOMAIN_ACCESSIBLE=false
        
        # First try a basic HTTPS connection to the root domain
        if timeout 15 curl -f -s --max-time 10 --connect-timeout 5 "https://alexthola.com/" > /dev/null 2>&1; then
          echo "‚úÖ Domain alexthola.com is accessible via HTTPS"
          DOMAIN_ACCESSIBLE=true
        elif timeout 15 curl -f -s --max-time 10 --connect-timeout 5 "http://alexthola.com/" > /dev/null 2>&1; then
          echo "‚úÖ Domain alexthola.com is accessible via HTTP"
          DOMAIN_ACCESSIBLE=true  
        else
          # Try alternative endpoints that might respond even if main site is down
          if timeout 10 curl -s --max-time 5 --connect-timeout 3 "https://alexthola.com/health" > /dev/null 2>&1; then
            echo "‚úÖ Domain alexthola.com is accessible via health endpoint"
            DOMAIN_ACCESSIBLE=true
          else
            echo "‚ö†Ô∏è Domain alexthola.com is not yet accessible via HTTP(S) - DNS may not be configured"
          fi
        fi
        
        if [ "$DOMAIN_ACCESSIBLE" = "true" ]; then
          echo "accessible=true" >> $GITHUB_OUTPUT
        else
          echo "accessible=false" >> $GITHUB_OUTPUT
        fi
        
        # Check if we can reach the health endpoint (might not exist yet on first deploy)
        if timeout 15 curl -f -s --max-time 10 "https://alexthola.com/health" > /dev/null 2>&1; then
          echo "‚úÖ Existing deployment is healthy"
        else
          echo "‚ÑπÔ∏è No existing deployment detected (normal for first deployment)"
        fi

  # Deploy to DigitalOcean App Platform
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 15  # Optimized: broken into smaller steps with individual timeouts
    needs: deployment-check
    if: needs.deployment-check.outputs.deploy-enabled == 'true'
    environment: production
    steps:
    - name: Download build artifacts
      uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4.1.8
      with:
        name: rust-build-artifacts
        path: .
        run-id: ${{ github.event.workflow_run.id }}
        github-token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Checkout deployment configuration
      uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7
      with:
        sparse-checkout: |
          .do/
          Dockerfile
          *.toml
          *.md
          public/
          style/
        sparse-checkout-cone-mode: false
    
    - name: Deploy to DigitalOcean
      id: deploy
      timeout-minutes: 8  # Most deployments complete in 3-5 minutes
      uses: digitalocean/app_action@v1 # NOTE: Cannot pin to SHA - v1 tags removed, v2 is complete rewrite. Switch to v2 after https://github.com/digitalocean/app_action/issues/123
      with:
        app_name: blog
        token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
    
    - name: Wait for deployment propagation
      timeout-minutes: 2  # Simple wait shouldn't exceed this
      run: |
        set -euo pipefail  # Exit on error, undefined vars, and pipe failures
        
        echo "Waiting for deployment to propagate..."
        sleep 60  # Give DigitalOcean time to deploy and start the application
    
    - name: Post-deployment health check
      timeout-minutes: 10  # Optimized: health checks with exponential backoff
      run: |
        set -euo pipefail  # Exit on error, undefined vars, and pipe failures
        
        echo "Starting comprehensive health checks..."
        
        # Function to check multiple endpoints with retry
        comprehensive_health_check() {
          local max_attempts=10  # Optimized: reduced attempts with better timing
          local timeout=10
          local attempt=1
          local max_wait=30  # Optimized: reduced max wait time
          local endpoints=(
            "https://alexthola.com/health"
            "https://blog-web.ondigitalocean.app/health"
          )
          
          while (( attempt <= max_attempts )); do
            echo "Health check attempt $attempt of $max_attempts"
            
            for endpoint in "${endpoints[@]}"; do
              echo "Testing endpoint: $endpoint"
              
              if timeout 15 curl -f -s --max-time $timeout "$endpoint" > /dev/null 2>&1; then
                echo "‚úÖ Application is healthy at $endpoint"
                
                # Get and display health check response (with timeout)
                echo "Health check response:"
                timeout 10 curl -s "$endpoint" | jq '.' 2>/dev/null || timeout 10 curl -s "$endpoint"
                return 0
              else
                echo "‚ùå Health check failed for $endpoint"
              fi
            done
            
            if (( attempt < max_attempts )); then
              local wait_time=$((timeout + attempt * 3))  # Reduced multiplier
              wait_time=$((wait_time > max_wait ? max_wait : wait_time))  # Cap wait time
              echo "All endpoints failed, waiting ${wait_time} seconds before retry..."
              sleep $wait_time
            fi
            
            ((attempt++))
          done
          
          echo "‚ùå All health checks failed after $max_attempts attempts"
          echo "This might indicate a deployment issue or DNS propagation delay"
          return 1
        }
        
        comprehensive_health_check
    
    - name: Validate core functionality
      timeout-minutes: 5  # Functional tests should be quick
      run: |
        set -euo pipefail  # Exit on error, undefined vars, and pipe failures
        
        echo "Validating core application functionality..."
        
        # Test main page
        if timeout 20 curl -f -s --max-time 15 "https://alexthola.com/" > /dev/null; then
          echo "‚úÖ Main page is accessible"
        else
          echo "‚ùå Main page is not accessible"
        fi
        
        # Test RSS feed
        if timeout 15 curl -f -s --max-time 10 "https://alexthola.com/rss.xml" > /dev/null; then
          echo "‚úÖ RSS feed is accessible"
        else
          echo "‚ö†Ô∏è RSS feed is not accessible"
        fi
        
        # Test sitemap
        if timeout 15 curl -f -s --max-time 10 "https://alexthola.com/sitemap.xml" > /dev/null; then
          echo "‚úÖ Sitemap is accessible"  
        else
          echo "‚ö†Ô∏è Sitemap is not accessible"
        fi
    
    - name: Performance and security validation
      timeout-minutes: 3  # Performance checks should be fast
      run: |
        set -euo pipefail  # Exit on error, undefined vars, and pipe failures
        
        echo "Running performance and security checks..."
        
        # Check response time (with timeout)
        echo "Testing response time..."
        RESPONSE_TIME=$(timeout 30 curl -w "%{time_total}" -s -o /dev/null "https://alexthola.com/" || echo "timeout")
        
        if [ "$RESPONSE_TIME" = "timeout" ]; then
          echo "‚ö†Ô∏è Response time test timed out (>30s)"
        else
          echo "Response time: ${RESPONSE_TIME}s"
          # Warn if response time is slow (using awk instead of bc for portability)
          if awk "BEGIN {exit !($RESPONSE_TIME > 3.0)}"; then
            echo "‚ö†Ô∏è Response time is slow (>${RESPONSE_TIME}s). Consider performance optimization."
          else
            echo "‚úÖ Response time is acceptable (${RESPONSE_TIME}s)"
          fi
        fi
        
        # Check security headers (with timeout)
        echo "Checking security headers..."
        HEADERS=$(timeout 20 curl -I -s "https://alexthola.com/" || echo "")
        
        if echo "$HEADERS" | grep -i "strict-transport-security" > /dev/null; then
          echo "‚úÖ HSTS header present"
        else
          echo "‚ö†Ô∏è HSTS header missing"
        fi
        
        if echo "$HEADERS" | grep -i "x-content-type-options" > /dev/null; then
          echo "‚úÖ X-Content-Type-Options header present"
        else
          echo "‚ö†Ô∏è X-Content-Type-Options header missing"
        fi
        
        # Check SSL certificate (with timeout)
        echo "Checking SSL certificate..."
        if timeout 15 bash -c "openssl s_client -connect alexthola.com:443 -servername alexthola.com < /dev/null 2>/dev/null | openssl x509 -noout -dates"; then
          echo "‚úÖ SSL certificate is valid"
        else
          echo "‚ö†Ô∏è SSL certificate issue detected or check timed out"
        fi

  # Deployment status notification
  notify:
    runs-on: ubuntu-latest
    timeout-minutes: 2  # Notification should be very quick
    needs: [deployment-check, deploy]
    if: always()
    steps:
    - name: Deployment Summary
      run: |
        set -euo pipefail  # Exit on error, undefined vars, and pipe failures
        
        echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ needs.deployment-check.outputs.deploy-enabled }}" = "true" ]; then
          echo "‚úÖ **DigitalOcean Configuration**: Enabled" >> $GITHUB_STEP_SUMMARY
        else
          echo "‚ùå **DigitalOcean Configuration**: Missing secrets" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Required secrets:**" >> $GITHUB_STEP_SUMMARY
          echo "- \`DIGITALOCEAN_ACCESS_TOKEN\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`SURREAL_ADDRESS\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`SURREAL_PASSWORD\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`SURREAL_NS\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`SURREAL_DB\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`SURREAL_USERNAME\`" >> $GITHUB_STEP_SUMMARY
          exit 0
        fi
        
        if [ "${{ needs.deploy.result }}" = "success" ]; then
          echo "‚úÖ **Deployment Status**: Successful" >> $GITHUB_STEP_SUMMARY
          echo "üåê **Application URL**: https://alexthola.com" >> $GITHUB_STEP_SUMMARY
        elif [ "${{ needs.deploy.result }}" = "failure" ]; then
          echo "‚ùå **Deployment Status**: Failed" >> $GITHUB_STEP_SUMMARY
        elif [ "${{ needs.deploy.result }}" = "skipped" ]; then
          echo "‚è≠Ô∏è **Deployment Status**: Skipped (configuration not ready)" >> $GITHUB_STEP_SUMMARY
        else
          echo "‚ö†Ô∏è **Deployment Status**: Unknown" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Domain Status**: ${{ needs.deployment-check.outputs.domain-accessible == 'true' && '‚úÖ Accessible' || '‚ö†Ô∏è DNS not configured' }}" >> $GITHUB_STEP_SUMMARY